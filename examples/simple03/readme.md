好的，我将结合我们之前讨论的所有内容，包括项目目标、功能、技术栈、架构设计、开发流程、未来的扩展方向，以及新增的卡牌生成工具、规则定义工具和测试工具，生成一份完整的软件工程指示书文本。

**完整的软件工程指示书**

**项目名称：** LLM 驱动的对话式卡牌游戏

**版本号：** 1.0

**1. 项目目标**

*   开发一款基于自然语言交互的卡牌游戏，玩家可以使用自然语言指令与 AI 对手进行对战。
*   提供一个直观的用户界面，实时渲染游戏状态。
*   实现预设卡牌的展示、抽取和使用。
*   利用 LLM 解析用户指令和生成 AI 对手响应，增加游戏互动性。
*   实现卡牌的难度评分系统，为卡牌平衡提供参考。
*   提供一个独立的卡牌生成工具，方便创建和编辑卡牌数据。
*   提供一个独立的规则定义工具，方便设置和修改游戏规则。
*    提供一个测试工具，方便验证各个模块的功能。

**2. 功能需求**

*   **核心游戏功能：**
    *   **卡牌管理：**
        *   加载预设的卡牌数据（`cards.json`）。
        *   实现从卡牌库中随机抽牌的功能。
        *   展示玩家手牌和卡牌信息（名称、类型、难度评分）。
    *   **游戏状态管理：**
        *   记录玩家和 AI 对手的生命值。
        *   控制游戏回合（玩家回合和 AI 回合）。
        *   记录游戏日志（玩家操作、AI 响应）。
        *   实现游戏胜负判断。
    *   **自然语言交互：**
        *   解析用户以自然语言输入的指令，转换为游戏可执行的动作。
        *   生成 AI 对手的自然语言响应，增加游戏互动性。
    *   **UI 交互：**
        *   使用 Streamlit 构建用户界面。
        *   实时展示游戏状态（生命值、回合、日志）。
        *   实时展示玩家手牌和卡牌信息。
        *   提供用户输入框，接收自然语言指令。
    *   **难度评分:**
        *   根据卡牌的属性，效果，类型等， 提供卡牌难度评分。
*   **工具功能：**
    *    **卡牌生成工具：**
        *   提供一个界面，让用户可以定义卡牌的属性（例如：名称，类型，攻击，防御，生命值，法力消耗等）。
        *   提供一个界面， 让用户可以定义卡牌效果，例如伤害，治疗，吸血， 增益， 减益 等。
        *   提供一个图形界面，让用户更好的管理和浏览 卡牌。
        *   支持将卡牌数据保存为 JSON 文件（方便导入到游戏中）。
    *   **规则定义工具：**
        *   提供一个界面， 用户可以修改游戏参数， 例如初始生命值， 初始资源等。
        *   提供一个界面，用户可以定义简单的游戏规则。
        *   将规则定义以 JSON 的形式进行保存。
        *   允许游戏读取自定义的规则。
    *  **测试工具:**
         *  允许用户定义测试用例， 包括游戏初始状态， 玩家指令序列， 预期结果。
         *   自动执行测试用例，验证游戏逻辑。
         *   记录测试结果，并生成测试报告。

**3. 技术栈**

*   **编程语言：** Python (>= 3.7)
*   **UI 框架：** Streamlit
*   **LLM 框架：** Langchain
*   **LLM 模型：** OpenAI (或其他兼容的 LLM)
*   **测试框架:** pytest（非必要，但推荐）
*   **依赖库：**
    *   streamlit
    *   langchain
    *   python-dotenv
    *   openai
    *   json
    *   os
    *   random

**4. 架构设计**

*   **模块化设计：** 项目采用模块化架构，各个模块功能明确、职责清晰。
    *    `prompts.py`: 存储提示词模板，用于 `langchain` 的模板调用。
    *   `card_cost_model.py`: 负责计算卡牌的难度评分。
    *   `game_manager.py`: 管理游戏状态和游戏逻辑，并读取规则定义工具生成的规则数据。
    *   `card_manager.py`: 管理卡牌数据和抽取卡牌逻辑，并读取卡牌生成工具生成的卡牌数据。
    *    `player_manager.py`: 管理玩家资源信息，例如金币，经验等。
    *   `llm_interaction.py`: 负责 LLM 的交互（解析用户指令、生成 AI 响应）。
    *   `streamlit_gui.py`: 使用 Streamlit 构建用户界面， 将所有的模块串联起来。
    *     `card_generator.py`:  提供一个 UI  界面， 用于生成卡牌数据。
    *   `rule_editor.py`:  提供一个 UI 界面，用于设置游戏规则。
      *   `test_tool.py`: 提供一个 UI 界面， 用于定义和自动运行测试用例。
    *  `main.py`:  游戏的主入口。
    *   `cards.json`: 存储预设卡牌基础数据， 可以通过卡牌生成工具进行修改。
      *    `test_cases.json`: 存储默认测试用例， 可以通过测试工具进行修改。
*   **数据流：**
    1.  用户可以使用 `card_generator.py`  和 `rule_editor.py` 生成或者编辑卡牌数据和游戏规则，数据分别保存到 `cards.json` 和  `game_rules.json`。
    2.  玩家在 Streamlit UI（`streamlit_gui.py`）输入自然语言指令。
    3.  `streamlit_gui.py` 将用户输入传递给 `llm_interaction.py` 进行处理。
    4.  `llm_interaction.py` 使用 `langchain` 解析用户指令。
    5.  解析后的动作信息传递给 `game_manager.py`，更新游戏状态。
    6.   `game_manager.py` 根据游戏状态和 AI 逻辑决定 AI 的操作。
    7. 如果当前是 AI 回合，则 `llm_interaction.py` 使用 `langchain` 生成 AI 的响应。
    8.   UI 实时渲染游戏状态和日志。
    9.   用户可以使用 `test_tool.py` 来验证游戏的正确性。

**5. 开发流程**

1.  **需求分析：** 明确项目目标、功能需求和技术选型 (已完成)。
2.  **系统设计：** 设计模块结构、数据流和接口 (已完成)。
3.  **编码实现：** 按照设计文档，编写各个模块的代码 (已完成)。
4.  **单元测试：** 对每个模块进行单元测试，确保代码逻辑正确。
5.  **集成测试：** 将各个模块整合，进行集成测试，验证系统整体功能的正确性。
6.   **系统测试:**  使用测试工具进行系统测试， 验证游戏逻辑，AI 响应等。
7.  **部署上线：** 将项目部署到服务器，供用户访问 (本地运行)。
8.  **维护更新：** 收集用户反馈，进行维护更新。

**6. 未来扩展方向**

*   **更复杂的卡牌效果：** 支持更多类型的卡牌效果（例如状态控制、增益、减益等）。
*  **卡牌合成和升级：** 允许用户合成或者升级卡牌。
*  **玩家资源系统：** 扩展玩家资源系统，实现玩家的成长。
*   **更强的 AI 对手：** 使用更先进的 AI 模型，提升 AI 对手的智能水平。
*   **更完善的规则：**  提供更加完善的规则定义， 例如卡牌费用，回合管理等。
*   **用户账号系统：** 增加用户账号系统，记录玩家数据。
*   **多人游戏模式：** 支持多人在线对战。
*    **游戏数据可视化:**  允许用户查看游戏数据。
*  **添加更多的提示词：**  例如  `卡牌描述 prompt`， `卡牌效果提示词` 等。
*  **更完善的测试工具:**  支持更多类型的测试，例如压力测试，随机测试。

**7. 风险评估**

*   **LLM 调用成本：** 大量使用 LLM 可能导致成本过高，需要进行监控，并制定相应的成本控制措施。
*   **LLM 输出不确定性：** LLM 输出的结果可能不稳定，需要设计适当的容错机制。
*   **初期数据较少：**  预设的 `cards.json` 的数据有限，可能需要扩展或者允许用户自助创建卡牌。
      *   **测试工具覆盖率有限:**  初期测试工具可能不完善，需要逐步添加更多的测试用例，提高测试覆盖率。


